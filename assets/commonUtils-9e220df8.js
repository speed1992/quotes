import{f as d,G as u}from"./index-cb971430.js";const y=(e,{options:t,setOptions:s},o)=>{const a=JSON.parse(JSON.stringify(t));if(e.trim().toLowerCase()==="all"){const r=f(e,t);let i;a[r].quotes===void 0?i=[]:i=a[r].quotes,a[r].quotes=[...i,...o]}else{const r=f(e,t);a[r].quotes=o}s(a)},p=(e,{options:t,setOptions:s},o)=>new Promise((a,r)=>{const i=e.toLowerCase();d(()=>fetch(u.STATIC_DATA.STATIC_QUOTES+i+".json")).then(n=>n.json()).then(n=>{o==null||o.map(l=>l(n)),y(e,{options:t,setOptions:s},n),a()}).catch(n=>r(n))}),f=(e,t)=>t.findIndex(({value:s})=>s===e),m=({philosopher:e,options:t})=>t.filter(({value:s})=>s===e)[0],T=({philosopher:e,options:t})=>{var s;return(s=t.filter(({value:o})=>o===e)[0])==null?void 0:s.quotes},w=(e,t)=>t[f(e,t)].fullName,D=(e,t)=>!!t[f(e,t)],g=async({userName:e,markedQuotes:t,openSnackbar:s,setSyncDate:o})=>{await d(async()=>await fetch(u.MARKED_QUOTES.BACKUP,{method:"post",headers:{"Content-Type":"application/json"},body:JSON.stringify({userName:e,markedQuotes:t,dateSynced:Date.now()})}))},S=async({userName:e,markedQuotes:t,openSnackbar:s,setMarkedQuotes:o})=>{var r,i,n,l;let a=await d(async()=>await fetch(u.MARKED_QUOTES.RESTORE,{method:"post",headers:{"Content-Type":"application/json"},body:JSON.stringify({userName:e})}));if(a=await a.json(),a!=null&&a.ok)try{const c=(i=(r=a==null?void 0:a.results)==null?void 0:r[0])==null?void 0:i.markedQuotes,h=Object.values(c).flat().length;if(c&&h>0)return{markedQuotesFromServer:c,dateFromServer:(l=(n=a==null?void 0:a.results)==null?void 0:n[0])==null?void 0:l.dateSynced}}catch(c){s(JSON.stringify(c))}else s(JSON.stringify(a.error))},C=async({apiCallType:e,userName:t,password:s,setIsLoggedIn:o,openSnackbar:a,setIsFetching:r})=>{const i=t.charAt(0).toUpperCase()+t.slice(1);let n;r(!0),e==="login"?n=await d(async()=>await fetch(u.USER.LOGIN,{method:"post",headers:{"Content-Type":"application/json"},body:JSON.stringify({userName:t,password:s})})):n=await d(async()=>await fetch(u.USER.CREATE,{method:"post",headers:{"Content-Type":"application/json"},body:JSON.stringify({userName:t,password:s})})),n=await n.json(),r(!1),n!=null&&n.ok?(o(!0),a(i+" "+JSON.stringify(n.serverResponse))):a(JSON.stringify(n.error))},A=e=>{let t=document.getElementsByTagName("html")[0];t.className="",e?t.classList.add("darkTheme"):t.classList.add("lightTheme")},E=(e,t)=>e.map(s=>m({philosopher:s.value,options:t})).reverse(),j=e=>[...e].sort((t,s)=>t.fullName.localeCompare(s.fullName));function v(e){let t=new Date,s=new Date(e);return t.setHours(0,0,0,0),t=t.getTime(),s=s.setHours(0,0,0,0),{currentClientDate:t,lastSyncClientDate:s}}async function N(e,t,s,o,a,r,i){let{markedQuotesFromServer:n,dateFromServer:l}=await S({userName:e,markedQuotes:t,openSnackbar:s,setMarkedQuotes:o});if(a(Date.now()),n){const c=Object.values(n).flat().length;c>r?(o(n),s("Auto-Sync : Restored all marked quotes!",4e3)):r>c&&(l=new Date(l),l.setHours(0,0,0,0),i>l&&await g({userName:e,markedQuotes:t,openSnackbar:s}))}}const P=e=>typeof e>"u",U=e=>Object.values(e).length===0&&e.constructor===Object;function R(){return([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g,e=>(e^crypto.getRandomValues(new Uint8Array(1))[0]&15>>e/4).toString(16))}export{T as a,v as b,N as c,D as d,E as e,j as f,f as g,U as h,P as i,w as j,C as k,p as l,A as s,R as u};
