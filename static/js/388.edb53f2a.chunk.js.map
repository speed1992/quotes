{"version":3,"file":"static/js/388.edb53f2a.chunk.js","mappings":"iNAEA,aAAO,OAAP,oBAAO,WAAoBA,EAAOC,EAAaC,EAAYC,EAAWC,EAASC,GAAxE,kFACGC,EAAQC,OAAOC,gBACjBC,EAAaH,EAAMI,SAEjBC,EAASL,EAAMM,YAER,YACbC,GAEIC,EAAI,IAAIC,SAAQ,SAACC,GAAD,OAAuBA,KAEtCP,EAXF,iBAYUQ,EAAIjB,EAZd,YAYqBiB,GAAC,OAAGhB,QAAH,IAAGA,OAAH,EAAGA,EAAaiB,SAZtC,wBAaKb,EAAkBY,IAClBE,EAAAA,EAAAA,IAAqBf,EAASa,EAAGhB,GAdtC,UAeWc,QAAQK,KAAK,CAACN,EAAGO,EAAapB,EAAYgB,GAAZ,MAAyBf,EAAYC,EAAWQ,KAfzF,QAY8CM,IAZ9C,kFAmBP,SAASI,EAAaC,EAASpB,EAAYC,EAAWQ,GAClD,IAAIY,EAAQ,IAAIC,yBAAyBF,GAMzC,OALAC,EAAME,KAAOvB,EACbqB,EAAMG,MAAQf,EAAOR,GACrBoB,EAAMI,KAAOhB,EAAOR,GAAWwB,KAC/BpB,OAAOC,gBAAgBoB,MAAML,GAEtB,IAAIR,SAAQ,SAACC,EAASa,GAAV,OAAsBN,EAAMO,MAAQd,K,aCjB3D,EAPc,SAAC,GAAoF,IAAlFhB,EAAiF,EAAjFA,MAAOC,EAA0E,EAA1EA,YAAa8B,EAA6D,EAA7DA,eAAgB1B,EAA6C,EAA7CA,kBAAmBD,EAA0B,EAA1BA,QAASF,EAAiB,EAAjBA,WACvEC,GAAY6B,EAAAA,EAAAA,KAAY,SAACC,GAAD,OAAWA,EAAMC,iBAAiB/B,aAE1DgC,GAAcC,EAAAA,EAAAA,cAAY,kBDL7B,SAAP,4CCK0CC,CAAKrC,EAAOC,EAAaC,EAAYC,EAAWC,EAASC,KAAoB,CAACJ,EAAaD,EAAOI,EAAS2B,EAAgB1B,EAAmBH,EAAYC,IAEhM,OAAO,oBAAQmC,QAAS9B,gBAAgBE,SAAW,kBAAMF,gBAAgBK,UAAWsB,EAA7E,UAA2F3B,gBAAgBE,SAAW,OAAS,OAAO","sources":["components/organisms/tools/audio/utils/speechUtils.js","components/organisms/tools/audio/audio.jsx"],"sourcesContent":["import { scrollToMemorizedRow } from '../../../../../common/utils/utils'\n\nexport async function play(index, currentData, voiceSpeed, voiceType, listRef, setScrollPosition) {\n    const synth = window.speechSynthesis,\n        isSpeaking = synth.speaking\n\n    const voices = synth.getVoices()\n\n    let cancel = () => {}\n    cancel()\n\n    let p = new Promise((resolve) => (cancel = resolve))\n\n    if (!isSpeaking)\n        for (let i = index; i < currentData?.length; i++) {\n            setScrollPosition(i)\n            scrollToMemorizedRow(listRef, i, currentData)\n            await Promise.race([p, getNextAudio(currentData[i]['quote'], voiceSpeed, voiceType, voices)])\n        }\n}\n\nfunction getNextAudio(message, voiceSpeed, voiceType, voices) {\n    let audio = new SpeechSynthesisUtterance(message)\n    audio.rate = voiceSpeed\n    audio.voice = voices[voiceType]\n    audio.lang = voices[voiceType].lang\n    window.speechSynthesis.speak(audio)\n\n    return new Promise((resolve, reject) => (audio.onend = resolve))\n}\n","import React, { useCallback } from 'react'\nimport { useSelector } from 'react-redux'\nimport { play } from './utils/speechUtils'\n\nconst Audio = ({ index, currentData, scrollPosition, setScrollPosition, listRef, voiceSpeed }) => {\n    const voiceType = useSelector((state) => state.philosophersData.voiceType)\n\n    const playHandler = useCallback(() => play(index, currentData, voiceSpeed, voiceType, listRef, setScrollPosition), [currentData, index, listRef, scrollPosition, setScrollPosition, voiceSpeed, voiceType])\n\n    return <button onClick={speechSynthesis.speaking ? () => speechSynthesis.cancel() : playHandler}>{speechSynthesis.speaking ? 'Stop' : 'Play'} Audio</button>\n}\nexport default Audio\n"],"names":["index","currentData","voiceSpeed","voiceType","listRef","setScrollPosition","synth","window","speechSynthesis","isSpeaking","speaking","voices","getVoices","cancel","p","Promise","resolve","i","length","scrollToMemorizedRow","race","getNextAudio","message","audio","SpeechSynthesisUtterance","rate","voice","lang","speak","reject","onend","scrollPosition","useSelector","state","philosophersData","playHandler","useCallback","play","onClick"],"sourceRoot":""}